diff -ur --exclude=.git a/BUILD.bazel b/BUILD.bazel
--- a/BUILD.bazel	2021-02-16 00:12:17.000000000 -0600
+++ b/BUILD.bazel	2021-02-16 00:13:55.000000000 -0600
@@ -40,11 +40,18 @@
     deps = select({
         "@io_bazel_rules_go//go/platform:aix": [
             "@org_golang_x_sys//unix",
+			"@com_github_prometheus_client_golang//prometheus:go_default_library",
+			"@com_github_prometheus_client_golang//prometheus/promauto:go_default_library"
         ],
         "@io_bazel_rules_go//go/platform:solaris": [
             "@org_golang_x_sys//unix",
+			"@com_github_prometheus_client_golang//prometheus:go_default_library",
+			"@com_github_prometheus_client_golang//prometheus/promauto:go_default_library"
         ],
-        "//conditions:default": [],
+		"//conditions:default": [
+			"@com_github_prometheus_client_golang//prometheus:go_default_library",
+			"@com_github_prometheus_client_golang//prometheus/promauto:go_default_library"
+		],
     }),
 )

diff -ur --exclude=.git a/db.go b/db.go
--- a/db.go	2021-02-15 23:59:56.000000000 -0600
+++ b/db.go	2021-02-16 00:03:38.000000000 -0600
@@ -11,6 +11,9 @@
    "sync"
    "time"
    "unsafe"
+
+	"github.com/prometheus/client_golang/prometheus"
+	"github.com/prometheus/client_golang/prometheus/promauto"
 )

 // The largest step that can be taken when remapping the mmap.
@@ -40,6 +43,46 @@
 // default page size for db is set to the OS page size.
 var defaultPageSize = os.Getpagesize()

+var (
+	mmapSize = promauto.NewGauge(prometheus.GaugeOpts{
+		Name: "bbolt_mmap_size",
+		Help: "Size of the mmap allocation in bytes",
+	})
+	numMmapResizes = promauto.NewCounter(prometheus.CounterOpts{
+		Name: "bbolt_mmap_resize_count_total",
+		Help: "Total number of times we have resized mmap",
+	})
+	readOnlyTxCount = promauto.NewCounter(prometheus.CounterOpts{
+		Name: "bbolt_read_only_tx_total",
+		Help: "Total number of times we started read only txs",
+	})
+	writableTxCount = promauto.NewCounter(prometheus.CounterOpts{
+		Name: "bbolt_read_write_tx_total",
+		Help: "Total number of times we started writeable txs",
+	})
+	readWriteTxLockWaitTime = promauto.NewHistogram(
+		prometheus.HistogramOpts{
+			Name:    "bbolt_read_write_tx_lock_time_milliseconds",
+			Help:    "The number of time waiting for the db read/write lock in milliseconds",
+			Buckets: []float64{100, 500, 1000, 2000, 4000, 10000},
+		},
+	)
+	readTxLockWaitTime = promauto.NewHistogram(
+		prometheus.HistogramOpts{
+			Name:    "bbolt_read_tx_lock_time_milliseconds",
+			Help:    "The number of time waiting for the db read lock in milliseconds",
+			Buckets: []float64{100, 500, 1000, 2000, 4000, 10000},
+		},
+	)
+	mmapWaitTime = promauto.NewHistogram(
+		prometheus.HistogramOpts{
+			Name:    "bbolt_mmap_time_milliseconds",
+			Help:    "The number of time waiting for mmap to complete in milliseconds",
+			Buckets: []float64{100, 500, 1000, 2000, 4000, 10000, 20000},
+		},
+	)
+)
+
 // The time elapsed between consecutive file locking attempts.
 const flockRetryTimeout = 50 * time.Millisecond

@@ -345,6 +388,7 @@
    if err != nil {
        return err
    }
+	mmapSize.Set(float64(size))

    // Dereference all mmap references before unmapping.
    if db.rwtx != nil {
@@ -539,8 +583,10 @@
 // else the database will not reclaim old pages.
 func (db *DB) Begin(writable bool) (*Tx, error) {
    if writable {
+		writableTxCount.Inc()
        return db.beginRWTx()
    }
+	readOnlyTxCount.Inc()
    return db.beginTx()
 }

@@ -553,7 +599,10 @@
    // Obtain a read-only lock on the mmap. When the mmap is remapped it will
    // obtain a write lock so all transactions must finish before it can be
    // remapped.
+	start := time.Now()
    db.mmaplock.RLock()
+	duration := time.Now().Sub(start)
+	readWriteTxLockWaitTime.Observe(float64(duration.Milliseconds()))

    // Exit if the database is not open yet.
    if !db.opened {
@@ -590,7 +639,10 @@

    // Obtain writer lock. This is released by the transaction when it closes.
    // This enforces only one writer transaction at a time.
+	start := time.Now()
    db.rwlock.Lock()
+	duration := time.Now().Sub(start)
+	readWriteTxLockWaitTime.Observe(float64(duration.Milliseconds()))

    // Once we have the writer lock then we can lock the meta pages so that
    // we can set up the transaction.
@@ -936,9 +988,13 @@
    p.id = db.rwtx.meta.pgid
    var minsz = int((p.id+pgid(count))+1) * db.pageSize
    if minsz >= db.datasz {
+		numMmapResizes.Inc()
+		start := time.Now()
        if err := db.mmap(minsz); err != nil {
            return nil, fmt.Errorf("mmap allocate error: %s", err)
        }
+		duration := time.Now().Sub(start)
+		mmapWaitTime.Observe(float64(duration.Milliseconds()))
    }

    // Move the page id high water mark.

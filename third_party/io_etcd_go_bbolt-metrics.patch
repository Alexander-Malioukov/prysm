diff --git a/db.go b/db.go
index 80b0095..5d5b991 100644
--- a/db.go
+++ b/db.go
@@ -11,6 +11,9 @@ import (
 	"sync"
 	"time"
 	"unsafe"
+
+	"github.com/prometheus/client_golang/prometheus"
+	"github.com/prometheus/client_golang/prometheus/promauto"
 )
 
 // The largest step that can be taken when remapping the mmap.
@@ -53,6 +56,46 @@ const (
 	FreelistMapType = FreelistType("hashmap")
 )
 
+var (
+	mmapSize = promauto.NewGauge(prometheus.GaugeOpts{
+		Name: "bbolt_mmap_size",
+		Help: "Size of the mmap allocation in bytes",
+	})
+	numMmapResizes = promauto.NewCounter(prometheus.CounterOpts{
+		Name: "bbolt_mmap_resize_count_total",
+		Help: "Total number of times we have resized mmap",
+	})
+	readOnlyTxCount = promauto.NewCounter(prometheus.CounterOpts{
+		Name: "bbolt_read_only_tx_total",
+		Help: "Total number of times we started read only txs",
+	})
+	writableTxCount = promauto.NewCounter(prometheus.CounterOpts{
+		Name: "bbolt_read_write_tx_total",
+		Help: "Total number of times we started writeable txs",
+	})
+	readWriteTxLockWaitTime = promauto.NewHistogram(
+		prometheus.HistogramOpts{
+			Name:    "bbolt_read_write_tx_lock_time_milliseconds",
+			Help:    "The number of time waiting for the db read/write lock in milliseconds",
+			Buckets: []float64{100, 500, 1000, 2000, 4000, 10000},
+		},
+	)
+	readTxLockWaitTime = promauto.NewHistogram(
+		prometheus.HistogramOpts{
+			Name:    "bbolt_read_tx_lock_time_milliseconds",
+			Help:    "The number of time waiting for the db read lock in milliseconds",
+			Buckets: []float64{100, 500, 1000, 2000, 4000, 10000},
+		},
+	)
+	mmapWaitTime = promauto.NewHistogram(
+		prometheus.HistogramOpts{
+			Name:    "bbolt_mmap_time_milliseconds",
+			Help:    "The number of time waiting for mmap to complete in milliseconds",
+			Buckets: []float64{100, 500, 1000, 2000, 4000, 10000, 20000},
+		},
+	)
+)
+
 // DB represents a collection of buckets persisted to a file on disk.
 // All data access is performed through transactions which can be obtained through the DB.
 // All the functions on DB will return a ErrDatabaseNotOpen if accessed before Open() is called.
@@ -345,6 +388,7 @@ func (db *DB) mmap(minsz int) error {
 	if err != nil {
 		return err
 	}
+	mmapSize.Set(float64(size))
 
 	// Dereference all mmap references before unmapping.
 	if db.rwtx != nil {
@@ -539,8 +583,10 @@ func (db *DB) close() error {
 // else the database will not reclaim old pages.
 func (db *DB) Begin(writable bool) (*Tx, error) {
 	if writable {
+		writableTxCount.Inc()
 		return db.beginRWTx()
 	}
+	readOnlyTxCount.Inc()
 	return db.beginTx()
 }
 
@@ -553,7 +599,10 @@ func (db *DB) beginTx() (*Tx, error) {
 	// Obtain a read-only lock on the mmap. When the mmap is remapped it will
 	// obtain a write lock so all transactions must finish before it can be
 	// remapped.
+	start := time.Now()
 	db.mmaplock.RLock()
+	duration := time.Now().Sub(start)
+	readWriteTxLockWaitTime.Observe(float64(duration.Milliseconds()))
 
 	// Exit if the database is not open yet.
 	if !db.opened {
@@ -590,7 +639,10 @@ func (db *DB) beginRWTx() (*Tx, error) {
 
 	// Obtain writer lock. This is released by the transaction when it closes.
 	// This enforces only one writer transaction at a time.
+	start := time.Now()
 	db.rwlock.Lock()
+	duration := time.Now().Sub(start)
+	readWriteTxLockWaitTime.Observe(float64(duration.Milliseconds()))
 
 	// Once we have the writer lock then we can lock the meta pages so that
 	// we can set up the transaction.
@@ -936,9 +988,13 @@ func (db *DB) allocate(txid txid, count int) (*page, error) {
 	p.id = db.rwtx.meta.pgid
 	var minsz = int((p.id+pgid(count))+1) * db.pageSize
 	if minsz >= db.datasz {
+		numMmapResizes.Inc()
+		start := time.Now()
 		if err := db.mmap(minsz); err != nil {
 			return nil, fmt.Errorf("mmap allocate error: %s", err)
 		}
+		duration := time.Now().Sub(start)
+		mmapWaitTime.Observe(float64(duration.Milliseconds()))
 	}
 
 	// Move the page id high water mark.
